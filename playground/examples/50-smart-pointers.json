{
  "order": 50,
  "title": "Smart Pointers Pattern",
  "snippet": "RAII and automatic resource management",
  "description": "Smart pointers implement RAII (Resource Acquisition Is Initialization) for automatic memory management. They use constructors to acquire resources and destructors to release them automatically when objects go out of scope. This prevents memory leaks and makes code exception-safe. Unlike raw pointers, smart pointers track ownership and cleanup. The Box<T> pattern wraps a heap-allocated value with automatic deallocation. Methods like unwrap() provide controlled access. This example shows implementing a basic smart pointer with constructor/destructor for safe memory management.",
  "code": [
    "extern printf(fmt: string, ...);",
    "extern malloc(size: int) ret *void;",
    "extern free(ptr: *void);",
    "",
    "# Smart pointer that owns heap data",
    "struct Box<T> {",
    "    data: *T,",
    "    ",
    "    # Constructor - allocate memory",
    "    frame new(value: T, size: int) ret Box<T> {",
    "        local ptr: *T = cast<*T>(malloc(size));",
    "        *ptr = value;",
    "        ",
    "        printf(\"[Box] Allocated %d bytes\\n\", size);",
    "        ",
    "        local box: Box<T>;",
    "        box.data = ptr;",
    "        return box;",
    "    }",
    "    ",
    "    # Get reference to data",
    "    frame get(this: *Box<T>) ret *T {",
    "        return this.data;",
    "    }",
    "    ",
    "    # Set value",
    "    frame set(this: *Box<T>, value: T) {",
    "        *(this.data) = value;",
    "    }",
    "    ",
    "    # Destructor - free memory",
    "    frame destroy(this: *Box<T>) {",
    "        if (this.data != nullptr) {",
    "            printf(\"[Box] Freeing memory\\n\");",
    "            free(cast<*void>(this.data));",
    "            this.data = nullptr;",
    "        }",
    "    }",
    "}",
    "",
    "# RAII wrapper for resources",
    "struct Resource {",
    "    id: int,",
    "    active: bool,",
    "    ",
    "    # Constructor - acquire resource",
    "    frame acquire(id: int) ret Resource {",
    "        printf(\"[Resource %d] Acquired\\n\", id);",
    "        local res: Resource;",
    "        res.id = id;",
    "        res.active = true;",
    "        return res;",
    "    }",
    "    ",
    "    # Use the resource",
    "    frame use(this: *Resource) {",
    "        if (this.active) {",
    "            printf(\"[Resource %d] Using\\n\", this.id);",
    "        }",
    "    }",
    "    ",
    "    # Destructor - release resource",
    "    frame release(this: *Resource) {",
    "        if (this.active) {",
    "            printf(\"[Resource %d] Released\\n\", this.id);",
    "            this.active = false;",
    "        }",
    "    }",
    "}",
    "",
    "frame main() ret int {",
    "    printf(\"=== Smart Pointer Demo ===\\n\");",
    "    ",
    "    # Create boxed integer",
    "    local box1: Box<int> = Box<int>.new(42, sizeof(int));",
    "    local ptr: *int = box1.get();",
    "    printf(\"Boxed value: %d\\n\", *ptr);",
    "    ",
    "    # Modify through box",
    "    box1.set(100);",
    "    printf(\"Modified value: %d\\n\", *box1.get());",
    "    ",
    "    # Manual cleanup",
    "    box1.destroy();",
    "    ",
    "    printf(\"\\n=== RAII Pattern Demo ===\\n\");",
    "    ",
    "    # Acquire and use resources",
    "    local res1: Resource = Resource.acquire(1);",
    "    local res2: Resource = Resource.acquire(2);",
    "    ",
    "    res1.use();",
    "    res2.use();",
    "    ",
    "    # Resources automatically released at scope end",
    "    res1.release();",
    "    res2.release();",
    "    ",
    "    printf(\"\\nAll resources cleaned up\\n\");",
    "    ",
    "    return 0;",
    "}"
  ]
}
