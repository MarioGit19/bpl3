{
  "order": 26,
  "title": "Generics - Basic",
  "snippet": "Generic function with type parameter",
  "description": "Generics enable writing code that works with multiple types while maintaining type safety. Type parameters (like <T>) are placeholders replaced with concrete types at compile-time through monomorphization - the compiler generates specialized versions for each used type. This provides zero-cost abstraction: generic code is as efficient as hand-written type-specific code. Generic functions must work for any type - they can only use operations valid for all types or constrained by bounds. Common generic patterns: containers (Vec<T>), algorithms (sort<T>), utility functions (swap<T>). This example shows basic generic function declaration and usage with different types.",
  "code": [
    "# Generic identity function - returns its input unchanged",
    "frame identity<T>(val: T) ret T {",
    "    local result: T;",
    "    result = val;",
    "    return result;",
    "}",
    "",
    "extern printf(fmt: string, ...);",
    "",
    "frame main() ret int {",
    "    # Call generic function with int",
    "    local num: int = 42;",
    "    local result_int: int = identity<int>(num);",
    "    printf(\"Identity of 42: %d\\n\", result_int);",
    "    ",
    "    # Call generic function with float",
    "    local pi: float = 3.14;",
    "    local result_float: float = identity<float>(pi);",
    "    printf(\"Identity of 3.14: %.2f\\n\", result_float);",
    "    ",
    "    # Another example",
    "    local val: int = 100;",
    "    local copy: int = identity<int>(val);",
    "    printf(\"Identity of 100: %d\\n\", copy);",
    "    ",
    "    return 0;",
    "}"
  ]
}
