{
  "order": 48,
  "title": "Generic Functions",
  "snippet": "Write type-agnostic code with generics",
  "description": "Generic functions in BPL allow you to write code that works with any type. Use the <T> syntax to declare type parameters that get filled in when the function is called. The compiler generates specialized versions for each concrete type used. Generics enable code reuse while maintaining type safety - you write the function once and use it with different types. Common patterns include generic max/min functions, container operations, and utility functions. You can use sizeof(T) to get type sizes and perform generic comparisons when operators are available for the type.",
  "code": [
    "extern printf(fmt: string, ...);",
    "",
    "# Generic function - works for any type",
    "frame printSize<T>(dummy: T) {",
    "    local size: int = sizeof(T);",
    "    printf(\"Type size: %d bytes\\n\", size);",
    "}",
    "",
    "# Generic max function",
    "frame max<T>(a: T, b: T) ret T {",
    "    # Generic comparison",
    "    if (a > b) {",
    "        return a;",
    "    }",
    "    return b;",
    "}",
    "",
    "# Generic identity function",
    "frame identity<T>(value: T) ret T {",
    "    return value;",
    "}",
    "",
    "frame main() ret int {",
    "    # Generic functions with different types",
    "    printSize<int>(0);",
    "    printSize<char>('A');",
    "    ",
    "    # Generic comparison",
    "    local maxInt: int = max<int>(10, 20);",
    "    printf(\"Max int: %d\\n\", maxInt);",
    "    ",
    "    # Generic identity",
    "    local val: int = identity<int>(42);",
    "    printf(\"Identity: %d\\n\", val);",
    "    ",
    "    return 0;",
    "}"
  ]
}
