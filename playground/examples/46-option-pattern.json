{
  "order": 46,
  "title": "Option Type Pattern",
  "snippet": "Handle nullable values safely with Option<T>",
  "description": "Option<T> is a type-safe way to represent values that might be absent, replacing null pointers. It's an enum with two variants: Some(T) containing a value, or None representing absence. This eliminates null pointer errors at compile time by forcing explicit handling of missing values. Pattern matching on Option makes the intent clear and prevents forgetting to check for null. Common patterns include unwrapping with defaults, chaining operations, and mapping over optional values. Option types are fundamental to writing robust code that handles missing data gracefully.",
  "code": [
    "# Generic Option type",
    "enum Option<T> {",
    "    Some(T),",
    "    None,",
    "}",
    "",
    "extern printf(fmt: string, ...);",
    "",
    "# Function that might not find a value",
    "frame findFirst(arr: int[5], size: int, target: int) ret Option<int> {",
    "    local i: int = 0;",
    "    loop (i < size) {",
    "        if (arr[i] == target) {",
    "            return Option<int>.Some(i);  # Return index",
    "        }",
    "        i = i + 1;",
    "    }",
    "    return Option<int>.None;  # Not found",
    "}",
    "",
    "# Get value or default",
    "frame unwrapOr(opt: Option<int>, defaultValue: int) ret int {",
    "    return match (opt) {",
    "        Option<int>.Some(value) => value,",
    "        Option<int>.None => defaultValue,",
    "    };",
    "}",
    "",
    "# Check if option has a value",
    "frame isSome(opt: Option<int>) ret bool {",
    "    return match (opt) {",
    "        Option<int>.Some(_) => true,",
    "        Option<int>.None => false,",
    "    };",
    "}",
    "",
    "# Map function - transform value if present  ",
    "frame mapOption(opt: Option<int>, multiplier: int) ret int {",
    "    return match (opt) {",
    "        Option<int>.Some(value) => value * multiplier,",
    "        Option<int>.None => -1,",
    "    };",
    "}",
    "",
    "frame main() ret int {",
    "    # Create array",
    "    local numbers: int[5] = [10, 20, 30, 40, 50];",
    "    ",
    "    # Search for values",
    "    local found: Option<int> = findFirst(numbers, 5, 30);",
    "    local notFound: Option<int> = findFirst(numbers, 5, 99);",
    "    ",
    "    # Pattern match on Option",
    "    local idx: int = match (found) {",
    "        Option<int>.Some(index) => index,",
    "        Option<int>.None => -1,",
    "    };",
    "    if (idx != -1) {",
    "        printf(\"Found at index: %d\\n\", idx);",
    "    } else {",
    "        printf(\"Not found\\n\");",
    "    }",
    "    ",
    "    # Unwrap with default",
    "    local idx1: int = unwrapOr(found, -1);",
    "    local idx2: int = unwrapOr(notFound, -1);",
    "    printf(\"Indices: %d, %d\\n\", idx1, idx2);",
    "    ",
    "    # Check if Some",
    "    local hasValue: bool = isSome(found);",
    "    printf(\"Has value: %d\\n\", hasValue);",
    "    ",
    "    # Map over option",
    "    local doubled: int = mapOption(found, 2);",
    "    if (doubled != -1) {",
    "        printf(\"Doubled: %d\\n\", doubled);",
    "    } else {",
    "        printf(\"No value to double\\n\");",
    "    }",
    "    ",
    "    return 0;",
    "}"
  ]
}
