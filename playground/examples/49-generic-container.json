{
  "order": 49,
  "title": "Generic Containers",
  "snippet": "Build reusable data structures with generics",
  "description": "Generic containers provide type-safe collections that work with any type. A Stack<T> stores elements of type T with push/pop operations. Using generics avoids code duplication - one implementation works for all types. The container maintains type safety: a Stack<int> can only store integers. Generics enable zero-cost abstractions through monomorphization - the compiler generates specialized code for each type. Common generic containers include stacks, queues, vectors, maps, and trees. This example demonstrates a simple generic stack implementation.",
  "code": [
    "extern printf(fmt: string, ...);",
    "extern malloc(size: int) ret *void;",
    "",
    "# Generic Stack data structure",
    "struct Stack<T> {",
    "    items: *T,",
    "    capacity: int,",
    "    size: int,",
    "    ",
    "    # Create new stack",
    "    frame new(capacity: int, itemSize: int) ret Stack<T> {",
    "        local totalSize: int = itemSize * capacity;",
    "        local items: *T = cast<*T>(malloc(totalSize));",
    "        ",
    "        local stack: Stack<T>;",
    "        stack.items = items;",
    "        stack.capacity = capacity;",
    "        stack.size = 0;",
    "        return stack;",
    "    }",
    "    ",
    "    # Push element onto stack",
    "    frame push(this: *Stack<T>, value: T) ret bool {",
    "        if (this.size >= this.capacity) {",
    "            return false;  # Stack full",
    "        }",
    "        ",
    "        this.items[this.size] = value;",
    "        this.size += 1;",
    "        return true;",
    "    }",
    "    ",
    "    # Pop element from stack",
    "    frame pop(this: *Stack<T>) ret T {",
    "        if (this.size > 0) {",
    "            this.size -= 1;",
    "            return this.items[this.size];",
    "        }",
    "        # Return default value (0) if empty",
    "        local defaultVal: T;",
    "        return defaultVal;",
    "    }",
    "    ",
    "    # Peek at top element",
    "    frame peek(this: *Stack<T>) ret T {",
    "        if (this.size > 0) {",
    "            return this.items[this.size - 1];",
    "        }",
    "        local defaultVal: T;",
    "        return defaultVal;",
    "    }",
    "    ",
    "    # Check if empty",
    "    frame isEmpty(this: *Stack<T>) ret bool {",
    "        return this.size == 0;",
    "    }",
    "    ",
    "    # Get current size",
    "    frame getSize(this: *Stack<T>) ret int {",
    "        return this.size;",
    "    }",
    "}",
    "",
    "frame main() ret int {",
    "    # Create stack of integers",
    "    local intStack: Stack<int> = Stack<int>.new(10, sizeof(int));",
    "    ",
    "    # Push elements",
    "    intStack.push(10);",
    "    intStack.push(20);",
    "    intStack.push(30);",
    "    intStack.push(40);",
    "    ",
    "    printf(\"Stack size: %d\\n\", intStack.getSize());",
    "    printf(\"Top element: %d\\n\", intStack.peek());",
    "    ",
    "    # Pop elements",
    "    printf(\"\\nPopping elements:\\n\");",
    "    loop (!intStack.isEmpty()) {",
    "        local value: int = intStack.pop();",
    "        printf(\"%d\\n\", value);",
    "    }",
    "    ",
    "    # Create stack of floats",
    "    local floatStack: Stack<float> = Stack<float>.new(5, sizeof(float));",
    "    floatStack.push(3.14);",
    "    floatStack.push(2.71);",
    "    floatStack.push(1.41);",
    "    ",
    "    printf(\"\\nFloat stack size: %d\\n\", floatStack.getSize());",
    "    printf(\"Top float: %.2f\\n\", floatStack.peek());",
    "    ",
    "    return 0;",
    "}"
  ]
}
