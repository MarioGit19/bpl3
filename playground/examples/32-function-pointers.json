{
  "order": 32,
  "title": "Function Pointers",
  "snippet": "Store and call functions through pointers",
  "description": "Function pointers allow you to store references to functions and call them dynamically. Useful for callbacks and higher-order functions.",
  "code": "# Define a callback function signature\ntype MathOperation = Func<int>(int, int);\n\n# Concrete implementations\nframe add_impl(a: int, b: int) ret int {\n    return a + b;\n}\n\nframe subtract_impl(a: int, b: int) ret int {\n    return a - b;\n}\n\nframe multiply_impl(a: int, b: int) ret int {\n    return a * b;\n}\n\n# Function that takes a function pointer as argument\nframe applyOperation(a: int, b: int, op: MathOperation) ret int {\n    return op(a, b);\n}\n\nextern printf(fmt: string, ...);\n\nframe main() ret int {\n    local a: int = 10;\n    local b: int = 5;\n    \n    # Create function pointers\n    local add_fn: MathOperation = add_impl;\n    local sub_fn: MathOperation = subtract_impl;\n    local mul_fn: MathOperation = multiply_impl;\n    \n    # Call functions through pointers\n    local result1: int = add_fn(a, b);\n    local result2: int = sub_fn(a, b);\n    local result3: int = mul_fn(a, b);\n    \n    printf(\"%d + %d = %d\\n\", a, b, result1);\n    printf(\"%d - %d = %d\\n\", a, b, result2);\n    printf(\"%d * %d = %d\\n\", a, b, result3);\n    \n    # Pass function pointer to another function\n    local result4: int = applyOperation(20, 4, add_fn);\n    local result5: int = applyOperation(20, 4, mul_fn);\n    \n    printf(\"\\nUsing applyOperation:\\n\");\n    printf(\"Add 20 and 4: %d\\n\", result4);\n    printf(\"Multiply 20 and 4: %d\\n\", result5);\n    \n    return 0;\n}"
}
