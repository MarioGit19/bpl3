{
  "order": 45,
  "title": "Result Type Pattern",
  "snippet": "Modern error handling with Result<T, E>",
  "description": "The Result<T, E> pattern is a modern approach to error handling that makes errors explicit and forces you to handle them. Result is a generic enum with Ok(T) for success and Err(E) for errors. Unlike exceptions, errors are visible in function signatures, making code more predictable. Use pattern matching to handle both success and failure cases. This pattern eliminates null checks and improves type safety. You can chain operations, propagate errors, and provide default values. Result types make error handling a first-class language feature rather than an afterthought.",
  "code": [
    "# Generic Result type for error handling",
    "enum Result<T, E> {",
    "    Ok(T),",
    "    Err(E),",
    "}",
    "",
    "# Error types",
    "enum MathError {",
    "    DivisionByZero,",
    "    Overflow,",
    "    InvalidInput,",
    "}",
    "",
    "extern printf(fmt: string, ...);",
    "",
    "# Function that can fail",
    "frame safeDivide(a: int, b: int) ret Result<int, MathError> {",
    "    if (b == 0) {",
    "        return Result<int, MathError>.Err(MathError.DivisionByZero);",
    "    }",
    "    local result: int = a / b;",
    "    return Result<int, MathError>.Ok(result);",
    "}",
    "",
    "# Another failable operation",
    "frame parseInt(s: string) ret Result<int, MathError> {",
    "    # Simplified - just demonstrate the pattern",
    "    if (s == \"invalid\") {",
    "        return Result<int, MathError>.Err(MathError.InvalidInput);",
    "    }",
    "    return Result<int, MathError>.Ok(42);",
    "}",
    "",
    "# Helper to check if Result is Ok",
    "frame isOk(r: Result<int, MathError>) ret bool {",
    "    return match (r) {",
    "        Result<int, MathError>.Ok(_) => true,",
    "        Result<int, MathError>.Err(_) => false,",
    "    };",
    "}",
    "",
    "# Handle result with pattern matching",
    "frame processResult(r: Result<int, MathError>) ret int {",
    "    if (isOk(r)) {",
    "        printf(\"Success\\n\");",
    "        return 42;",
    "    }",
    "    # Handle error case",
    "    printf(\"Error occurred\\n\");",
    "    return -1;",
    "}",
    "",
    "# Unwrap with default value",
    "frame unwrapOr(r: Result<int, MathError>, defaultValue: int) ret int {",
    "    return match (r) {",
    "        Result<int, MathError>.Ok(value) => value,",
    "        Result<int, MathError>.Err(_) => defaultValue,",
    "    };",
    "}",
    "",
    "frame main() ret int {",
    "    # Successful operation",
    "    local r1: Result<int, MathError> = safeDivide(10, 2);",
    "    local _val1: int = processResult(r1);",
    "    ",
    "    # Failed operation",
    "    local r2: Result<int, MathError> = safeDivide(10, 0);",
    "    local _val2: int = processResult(r2);",
    "    ",
    "    # Parse operation",
    "    local r3: Result<int, MathError> = parseInt(\"valid\");",
    "    local r4: Result<int, MathError> = parseInt(\"invalid\");",
    "    ",
    "    # Unwrap with default",
    "    local v1: int = unwrapOr(r3, 0);",
    "    local v2: int = unwrapOr(r4, 0);",
    "    printf(\"Parsed values: %d, %d\\n\", v1, v2);",
    "    ",
    "    return 0;",
    "}"
  ]
}
