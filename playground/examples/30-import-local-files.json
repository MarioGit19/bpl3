{
  "order": 30,
  "title": "Import from Project Files",
  "snippet": "Import functions and types from local project files",
  "description": "BPL's module system enables code organization across multiple files. Import from local files using relative paths: './' for current directory, '../' for parent, './subdir/' for subdirectories. Import specific items with 'import [item1, item2] from \"./module.bpl\"'. Only exported items from the target module can be imported. This promotes modular design: split large programs into focused modules, group related functionality, create reusable libraries. Module resolution happens at compile-time. Circular dependencies are not allowed - if A imports B and B imports A, refactor shared code to a third module C. This example shows importing and using code from local modules.",
  "code": "# In a real project, you would have multiple .bpl files:\n# - utils.bpl (containing utility functions)\n# - types.bpl (containing type definitions)\n# - main.bpl (this file)\n# Use: import [Point] from \"./types.bpl\";\n\n# For this example, we define the types locally\nstruct Point {\n    x: int,\n    y: int,\n}\n\nstruct Config {\n    version: int,\n    enabled: bool,\n}\n\n# Utility functions (would be in utils.bpl)\nframe add(a: int, b: int) ret int {\n    return a + b;\n}\n\nframe multiply(a: int, b: int) ret int {\n    return a * b;\n}\n\nextern printf(fmt: string, ...);\n\nframe main() ret int {\n    # Use utility functions\n    local result1: int = add(10, 20);\n    local result2: int = multiply(5, 6);\n    printf(\"10 + 20 = %d\\n\", result1);\n    printf(\"5 * 6 = %d\\n\", result2);\n    \n    # Use types\n    local point: Point;\n    point.x = 100;\n    point.y = 200;\n    printf(\"Point at (%d, %d)\\n\", point.x, point.y);\n    \n    # Use Config type\n    local config: Config;\n    config.version = 1;\n    config.enabled = true;\n    printf(\"Config v%d, Enabled: %d\\n\", config.version, config.enabled);\n    \n    return 0;\n}"
}
