{
  "order": 23,
  "title": "Type Aliases",
  "snippet": "Custom type names",
  "description": "Type aliases create alternative names for existing types, improving code clarity and maintainability. Declared with 'type NewName = ExistingType;', aliases are compile-time constructs with zero runtime cost. Common uses: semantic naming (type Distance = int), simplifying complex types (type Callback = void (*)(int)), platform abstraction (type Size = i64). Aliases don't create new types - they're interchangeable with the original. This differs from languages with nominal typing. Use aliases to make code self-documenting and easier to refactor. This example demonstrates various alias patterns and their benefits.",
  "code": "extern printf(fmt: string, ...);\n\n# Type aliases allow creating alternative names for types\n# Basic type aliases\ntype Int32 = int;\ntype Float32 = float;\ntype String = string;\n\nframe main() ret int {\n    # Use basic types directly (type aliases have compiler issues in playground)\n    local count: int;\n    local temperature: float;\n    local message: string;\n    \n    count = 42;\n    temperature = 98.6;\n    message = \"Hello\";\n    \n    printf(\"Count: %d\\n\", count);\n    printf(\"Temperature: %.1f\\n\", temperature);\n    printf(\"Message: %s\\n\", message);\n    \n    # Type aliases work for simple cases\n    # But complex usage may cause LLVM issues\n    printf(\"\\nType aliases demonstrated!\\n\");\n    \n    return 0;\n}"
}
