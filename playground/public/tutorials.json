{
  "tutorials": [
    {
      "id": "hello-world",
      "title": "1. Hello World",
      "description": "Our first program will print the classic \"Hello World\" message. This is the entry point of any BPL program.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    call Console.log(\"Hello, World!\");\n}\n"
    },
    {
      "id": "values",
      "title": "2. Values",
      "description": "BPL has various value types including strings, integers, floats, and booleans. Strings are pointers to characters (`*u8`). Integers can be signed (`i64`) or unsigned (`u64`). Floats are `f64` or `f32`.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    call Console.log(\"String: \", \"BPL Rocks\");\n    call Console.log(\"Integer: \", 1 + 1);\n    call Console.log(\"Float: \", 7.0 / 3.0);\n    \n    if 1 {\n        call Console.log(\"Boolean true\");\n    }\n}\n"
    },
    {
      "id": "variables",
      "title": "3. Variables",
      "description": "Variables are declared using `local` (or `global`) followed by the name, type, and optional initialization.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    local a: *u8 = \"initial\";\n    call Console.log(a);\n\n    local b: u64 = 1;\n    local c: u64 = 2;\n    call Console.log(b + c);\n\n    local d: u64 = 0;\n    call Console.log(d);\n}\n"
    },
    {
      "id": "constants",
      "title": "4. Constants",
      "description": "BPL supports constants using the `const` keyword. Constants must be initialized and cannot be changed.",
      "code": "import [Console] from \"std/io.x\";\nimport sin from \"libc\";\n\nextern sin(x: f64) ret f64;\n\nglobal const s: *u8 = \"constant\";\n\nframe main() {\n    call Console.log(s);\n\n    local const n: u64 = 500000000;\n    local d: f64 = 3e20 / n;\n    call Console.log(d);\n\n    call Console.log(call sin(n));\n}\n"
    },
    {
      "id": "for",
      "title": "5. For (Loops)",
      "description": "BPL has only one looping construct, `loop`, which creates an infinite loop. You can simulate `while` and `for` loops using `break` and `continue`.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    local i: u64 = 1;\n    # Basic loop (while i <= 3)\n    loop {\n        if i > 3 { break; }\n        call Console.log(i);\n        i = i + 1;\n    }\n\n    # Loop with continue\n    local j: u64 = 7;\n    loop {\n        if j > 9 { break; }\n        if j % 2 == 0 {\n            j = j + 1;\n            continue;\n        }\n        call Console.log(j);\n        j = j + 1;\n    }\n\n    # Infinite loop\n    loop {\n        call Console.log(\"loop\");\n        break;\n    }\n}\n"
    },
    {
      "id": "if-else",
      "title": "6. If/Else",
      "description": "Branching with `if` and `else` is straightforward. Braces `{}` are required.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    if 7 % 2 == 0 {\n        call Console.log(\"7 is even\");\n    } else {\n        call Console.log(\"7 is odd\");\n    }\n\n    if 8 % 4 == 0 {\n        call Console.log(\"8 is divisible by 4\");\n    }\n\n    local num: u64 = 9;\n    if num < 0 {\n        call Console.log(num, \" is negative\");\n    } else if num < 10 {\n        call Console.log(num, \" has 1 digit\");\n    } else {\n        call Console.log(num, \" has multiple digits\");\n    }\n}\n"
    },
    {
      "id": "switch",
      "title": "7. Switch",
      "description": "Switch statements express conditionals across many branches.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    local i: u64 = 2;\n    call Console.print(\"Write \", i, \" as \");\n    switch i {\n        case 1: { call Console.log(\"one\"); }\n        case 2: { call Console.log(\"two\"); }\n        case 3: { call Console.log(\"three\"); }\n        default: { call Console.log(\"unknown\"); }\n    }\n}\n"
    },
    {
      "id": "arrays",
      "title": "8. Arrays",
      "description": "Arrays are fixed-size sequences of elements of a specific type.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    local a: u64[5];\n    call Console.log(\"emp: \", a[0], \" \", a[4]);\n\n    a[4] = 100;\n    call Console.log(\"set: \", a[4]);\n    call Console.log(\"len: 5\");\n\n    local b: u64[5] = [1, 2, 3, 4, 5];\n    call Console.log(\"dcl: \", b[0], \" \", b[1], \" \", b[2], \" \", b[3], \" \", b[4]);\n}\n"
    },
    {
      "id": "structs-methods",
      "title": "9. Structs & Methods",
      "description": "Structs can have methods defined within them. Methods can access the struct instance using `this`.",
      "code": "import [Console] from \"std/io.x\";\n\nstruct User {\n    name: *u8,\n    age: i32,\n\n    frame sayHello() {\n        call Console.log(\"Hello, my name is \", this.name, \" and I am \", this.age, \" years old\");\n    }\n\n    frame setAge(newAge: i32) {\n        this.age = newAge;\n    }\n}\n\nframe main() {\n    local user: User;\n    user.name = \"Alice\";\n    user.age = 25;\n\n    call user.sayHello();\n\n    call user.setAge(30);\n    call Console.print(\"After setAge: \");\n    call user.sayHello();\n}\n"
    },
    {
      "id": "static-methods",
      "title": "10. Static Methods",
      "description": "Structs can also have static methods which are called on the type itself, not an instance. Useful for factory methods or utility functions.",
      "code": "import [Console] from \"std/io.x\";\n\nstruct Math {\n    static add(a: i32, b: i32) ret i32 {\n        return a + b;\n    }\n}\n\nstruct Counter {\n    count: i32,\n\n    static new(start: i32) ret Counter {\n        return cast<Counter>({count: start});\n    }\n\n    frame increment() {\n        this.count = this.count + 1;\n    }\n}\n\nframe main() {\n    local sum: i32 = call Math.add(10, 20);\n    call Console.log(\"Sum: \", sum);\n\n    local c: Counter = call Counter.new(5);\n    call Console.log(\"Counter start: \", c.count);\n\n    call c.increment();\n    call Console.log(\"Counter after inc: \", c.count);\n}\n"
    },
    {
      "id": "inheritance",
      "title": "11. Inheritance",
      "description": "Structs can inherit from other structs using the `:` syntax. Derived structs inherit fields and methods from the base struct.",
      "code": "import [Console] from \"std/io.x\";\n\nstruct Point {\n    x: i32,\n    y: i32,\n\n    frame init(x: i32, y: i32) {\n        this.x = x;\n        this.y = y;\n    }\n\n    frame print() {\n        call Console.log(\"Point(\", this.x, \", \", this.y, \")\");\n    }\n}\n\nstruct Point3D: Point {\n    z: i32,\n\n    frame init3D(x: i32, y: i32, z: i32) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    frame print3D() {\n        call Console.log(\"Point3D(\", this.x, \", \", this.y, \", \", this.z, \")\");\n    }\n}\n\nframe main() {\n    local p: Point3D;\n    call p.init3D(10, 20, 30);\n\n    call Console.log(\"Accessing inherited fields: x=\", p.x, \", y=\", p.y);\n    call Console.log(\"Accessing own field: z=\", p.z);\n\n    call Console.log(\"Calling inherited method: \");\n    call p.print();\n\n    call Console.log(\"Calling own method: \");\n    call p.print3D();\n}\n"
    },
    {
      "id": "tuples",
      "title": "12. Tuples",
      "description": "Tuples allow grouping multiple values of different types. They support destructuring and multiple return values.",
      "code": "import [Console] from \"std/io.x\";\n\nframe divide_with_remainder(a: i64, b: i64) ret (i64, i64) {\n    local quotient: i64 = a / b;\n    local remainder: i64 = a % b;\n    return (quotient, remainder);\n}\n\nframe main() {\n    # Basic tuple\n    local coords: (i64, i64) = (10, 20);\n    call Console.log(\"Coordinates: (\", coords.0, \", \", coords.1, \")\");\n\n    # Tuple return\n    local result: (i64, i64) = call divide_with_remainder(17, 5);\n    call Console.log(\"17 / 5 = \", result.0, \" remainder \", result.1);\n\n    # Destructuring\n    local (q: i64, r: i64) = result;\n    call Console.log(\"Destructured: q=\", q, \", r=\", r);\n}\n"
    },
    {
      "id": "generics",
      "title": "13. Generics",
      "description": "Generics allow writing code that works with multiple types. You can define generic structs and functions.",
      "code": "import [Console] from \"std/io.x\";\n\n# Generic Struct\nstruct Box<T> {\n    value: T,\n}\n\n# Generic Function\nframe identity<T>(val: T) ret T {\n    return val;\n}\n\nframe main() {\n    # Using generic struct\n    local b: Box<u64>;\n    b.value = 123;\n    call Console.log(\"Box value: \", b.value);\n\n    # Using generic function\n    local x: u64 = call identity<u64>(42);\n    call Console.log(\"Identity: \", x);\n\n    # Generic with different type\n    local b2: Box<*u8>;\n    b2.value = \"Hello Generic\";\n    call Console.log(\"Box string: \", b2.value);\n}\n"
    },
    {
      "id": "casting",
      "title": "14. Type Casting",
      "description": "Use the `cast<Type>(value)` syntax to convert between compatible types, such as integers, floats, and pointers.",
      "code": "import [Console] from \"std/io.x\";\n\nframe main() {\n    # Integer cast\n    local x: u64 = 1000;\n    local y: u8 = cast<u8>(x);\n    call Console.log(\"u64 \", x, \" cast to u8: \", y);\n\n    # Float cast\n    local f: f64 = 3.14159;\n    local i: u64 = cast<u64>(f);\n    call Console.log(\"f64 \", f, \" cast to u64: \", i);\n\n    # Pointer cast\n    local a: u8 = 42;\n    local ptr: *u8 = &a;\n    local addr: u64 = cast<u64>(ptr);\n    call Console.print(\"Pointer address: 0x\",);\n    call Console.print_hex(addr);\n}\n"
    },
    {
      "id": "variadic",
      "title": "15. Variadic Functions",
      "description": "Functions can accept a variable number of arguments using the `...` syntax. Arguments are accessed via the `args` array.",
      "code": "import [Console] from \"std/io.x\";\n\nframe sum(count: u64, ...:u64) ret u64 {\n    local total: u64 = 0;\n    local i: u64 = 0;\n\n    loop {\n        if i >= count {\n            break;\n        }\n        total = total + args[i];\n        i = i + 1;\n    }\n    return total;\n}\n\nframe main() {\n    local s: u64 = call sum(5, 10, 20, 30, 40, 50);\n    call Console.log(\"Sum of 5 numbers: \", s);\n}\n"
    },
    {
      "id": "error-handling",
      "title": "16. Error Handling",
      "description": "BPL supports structured error handling with `try`, `catch`, and `throw`. You can throw any struct as an exception.",
      "code": "import [Console] from \"std/io.x\";\n\nstruct MyError {\n    code: i32,\n}\n\nframe thrower(val: i32) {\n    if val < 0 {\n        call Console.log(\"Throwing error...\");\n        throw cast<MyError>({code: val});\n    }\n    call Console.log(\"Value is good: \", val);\n}\n\nframe main() {\n    try {\n        call thrower(-1);\n    } catch (e: MyError) {\n        call Console.log(\"Caught error with code: \", e.code);\n    }\n\n    try {\n        call thrower(10);\n    } catch (e: MyError) {\n        call Console.log(\"Should not be here\");\n    }\n}\n"
    },
    {
      "id": "pointers",
      "title": "17. Pointers & Memory",
      "description": "Direct memory management is possible using pointers (`*T`) and `std_malloc`/`std_free` from std/memory.x.",
      "code": "import [Console] from \"std/io.x\";\nimport std_malloc, std_free from \"std/memory.x\";\n\nframe main() {\n    # Allocate memory for 5 bytes\n    local ptr: *u8 = call std_malloc(5);\n    \n    # Write to memory\n    *ptr = 'H';\n    *(ptr + 1) = 'i';\n    *(ptr + 2) = '!';\n    *(ptr + 3) = 0; # Null terminator\n\n    call Console.log(\"From heap: \", ptr);\n\n    # Free memory\n    call std_free(ptr);\n}\n"
    }
  ]
}
